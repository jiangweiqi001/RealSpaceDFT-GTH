"""Structure utilities for random cluster generation.

Coordinates are in Bohr. Random clusters are generated by rejection sampling
with a minimum inter-atomic distance constraint.
"""

import numpy as np


def check_min_distance(coords, limit):
    """Check whether all inter-atomic distances exceed a threshold.

    Args:
        coords: Atomic coordinates, shape (n_atoms, 3), in Bohr.
        limit: Minimum allowed distance in Bohr.

    Returns:
        True if all pair distances are >= limit, otherwise False.
    """
    coords = np.asarray(coords, dtype=float)
    n = coords.shape[0]
    if n < 2:
        return True
    diff = coords[:, None, :] - coords[None, :, :]
    d2 = np.sum(diff ** 2, axis=-1)
    iu = np.triu_indices(n, k=1)
    return np.all(d2[iu] >= float(limit) ** 2)


def generate_random_cluster(elements, n_atoms_range, box_size, min_distance, rng=None, max_tries=2000):
    """Generate a random atomic cluster by rejection sampling.

    Atoms are placed uniformly within a cubic box. Samples that violate the
    minimum distance are rejected up to max_tries.

    Args:
        elements: Sequence of allowed element symbols.
        n_atoms_range: Integer or (min, max) tuple for atom count.
        box_size: Box lengths [Lx, Ly, Lz] in Bohr.
        min_distance: Minimum allowed inter-atomic distance in Bohr.
        rng: Optional NumPy random generator.
        max_tries: Maximum attempts before giving up.

    Returns:
        Tuple (coords, symbols) with coordinates in Bohr and element symbols.

    Raises:
        RuntimeError: If a valid cluster cannot be generated.
    """
    if rng is None:
        rng = np.random.default_rng()
    if isinstance(n_atoms_range, int):
        n_min, n_max = n_atoms_range, n_atoms_range
    else:
        n_min, n_max = n_atoms_range
    box_size = np.asarray(box_size, dtype=float)
    low = -0.5 * box_size
    high = 0.5 * box_size
    for _ in range(max_tries):
        n_atoms = int(rng.integers(n_min, n_max + 1))
        symbols = rng.choice(elements, size=n_atoms, replace=True).tolist()
        coords = rng.uniform(low, high, size=(n_atoms, 3))
        if check_min_distance(coords, min_distance):
            return coords, symbols
    raise RuntimeError("Failed to generate a valid cluster within max_tries")
